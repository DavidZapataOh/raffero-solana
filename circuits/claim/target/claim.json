{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"1926637342109448353","abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"path_indices","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"recipient","type":{"kind":"field"},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_hash","type":{"kind":"field"},"visibility":"public"},{"name":"recipient_binding","type":{"kind":"field"},"visibility":"public"},{"name":"raffle_id","type":{"kind":"field"},"visibility":"public"},{"name":"winner_index","type":{"kind":"field"},"visibility":"public"},{"name":"tree_depth","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"50":{"source":"use poseidon::poseidon2::Poseidon2;\n\n// Maximum Merkle tree depth (supports up to 2^20 = 1,048,576 participants)\nglobal MAX_DEPTH: u32 = 20;\n\n// Compute Poseidon2 hash of two Field elements\nfn hash2(a: Field, b: Field) -> Field {\n    Poseidon2::hash([a, b], 2)\n}\n\n// Compute Poseidon2 hash of a single Field element\nfn hash1(a: Field) -> Field {\n    Poseidon2::hash([a], 1)\n}\n\nfn main(\n    // PRIVATE INPUTS\n    secret: Field,\n    nullifier: Field,\n    siblings: [Field; MAX_DEPTH],\n    path_indices: [Field; MAX_DEPTH],  // 0 or 1 for each level\n    recipient: Field,\n    \n    // PUBLIC INPUTS\n    root: pub Field,\n    nullifier_hash: pub Field,\n    recipient_binding: pub Field,\n    raffle_id: pub Field,\n    winner_index: pub Field,\n    tree_depth: pub Field\n) {\n    // Convert tree_depth to u32 for comparisons\n    let depth = tree_depth as u32;\n    assert(depth <= MAX_DEPTH);\n    assert(depth > 0);\n    \n    // commitment = Poseidon2(secret, nullifier)\n    let commitment = hash2(secret, nullifier);\n    \n    let computed_nullifier_hash = hash2(nullifier, raffle_id);\n    assert(computed_nullifier_hash == nullifier_hash);\n    \n    let computed_recipient_binding = hash2(nullifier_hash, recipient);\n    assert(computed_recipient_binding == recipient_binding);\n    \n    let mut reconstructed_index: Field = 0;\n    let mut power_of_two: Field = 1;\n    for i in 0..MAX_DEPTH {\n        if i < depth {\n            let bit = path_indices[i];\n            // Ensure bit is 0 or 1\n            assert(bit * (bit - 1) == 0);\n            reconstructed_index = reconstructed_index + bit * power_of_two;\n            power_of_two = power_of_two * 2;\n        }\n    }\n    assert(reconstructed_index == winner_index);\n    \n    let mut current_hash = commitment;\n    for i in 0..MAX_DEPTH {\n        if i < depth {\n            let sibling = siblings[i];\n            let is_right = path_indices[i];\n            \n            let left = if is_right == 0 { current_hash } else { sibling };\n            let right = if is_right == 0 { sibling } else { current_hash };\n            \n            current_hash = hash2(left, right);\n        }\n    }\n    assert(current_hash == root);\n    \n    assert(raffle_id != 0);\n}\n\n#[test]\nfn test_hash2() {\n    let h = hash2(1, 2);\n    assert(h != 0);\n}\n\n#[test]\nfn test_hash1() {\n    let h = hash1(42);\n    assert(h != 0);\n}\n\n#[test]\nfn test_simple_merkle_proof() {\n    let secret: Field = 123;\n    let nullifier: Field = 456;\n    let commitment = hash2(secret, nullifier);\n    \n    let leaf1 = hash2(789, 101112);\n    \n    let computed_root = hash2(commitment, leaf1);\n    \n    let mut siblings: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\n    siblings[0] = leaf1;\n    \n    let path_indices: [Field; MAX_DEPTH] = [0; MAX_DEPTH];\n  \n    let mut current = commitment;\n    let sibling = siblings[0];\n    let is_right = path_indices[0];\n    let left = if is_right == 0 { current } else { sibling };\n    let right = if is_right == 0 { sibling } else { current };\n    current = hash2(left, right);\n    \n    assert(current == computed_root);\n}\n","path":"/home/david/raffero-solana/circuits/claim/src/main.nr"},"57":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/david/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}